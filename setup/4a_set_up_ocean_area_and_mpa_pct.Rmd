---
title: 'Set up ocean area raster and MPA pct rasters'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'Figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(raster)
library(sf)
library(fasterize)

source('https://raw.githubusercontent.com/oharac/src/master/R/common.R')  ###
  ### includes library(tidyverse); library(stringr); dir_M points to ohi directory

dir_git <- '~/github/spp_risk_dists'

### project specific folders and info
source(file.path(dir_git, '_setup/common_fxns.R'))

```

# Summary

To define spatial areas more accurately, create rasters of WDPA and ocean area at Gall-Peters resolution of 0.25 km^2.  These can then be aggregated back to Gall Peters 10 km^2 working rasters, summing the total ocean area and total protected area within each working cell.

* Ocean area - use Natural Earth 10 m land polygons; mask over cell ID raster to exclude land.

# Data Sources

### WDPA

# Methods

## Ocean area raster

* Project Natural Earth 10M oceabn polygons into Gall-Peters equal area projection
* rasterize at 500 m resolution
* aggregate up to 10 km resolution


### Create a 10 km^2 Gall Peters projection cell ID raster

``` {r rasterize natural earth ocean polygons to Gall-Peters}

ocean_area_file <- file.path(dir_spatial, 'ocean_area_rast.tif')
cell_id_file    <- file.path(dir_spatial, 'cell_id_rast.tif')
# ocean_1km_file  <- file.path(dir_o_anx, 'spatial', 'ocean_1km.tif')
ocean_500m_file  <- file.path(dir_o_anx, 'spatial', 'ocean_500m.tif')

if(!file.exists(ocean_area_file)) {
  
  ocean_sf_wgs84 <- read_sf(file.path(dir_spatial, 'ne_10m_ocean', 'ne_10m_ocean.shp'))
  
  ### Annoyingly, this counts the Caspian Sea as ocean... so make a block,
  ### cut it out, and go from there.
  caspian_block <- matrix(c(45, 35, 45, 48, 56, 48, 56, 35, 45, 35), 
                          ncol = 2, byrow = TRUE)
  caspian_sf <- st_polygon(list(caspian_block)) %>% 
    st_sfc(crs = 4326)
  
  ocean_sf <- ocean_sf_wgs84 %>%
    st_difference(caspian_sf) %>%
    st_transform(gp_proj4)

  bbox_ocean <- st_bbox(ocean_sf)
  ext_r  <- extent(bbox_ocean$xmin, bbox_ocean$xmax, bbox_ocean$ymin, bbox_ocean$ymax)
  rast_base_500m <- raster(ext_r, crs = crs(gp_proj4), res = 500)
  rast_base_10km <- raster(ext_r, crs = crs(gp_proj4), res = 10000)
  
  if(!file.exists(ocean_500m_file)) {
    rast_ocean_500m <- fasterize(ocean_sf, rast_base_500m, 
                              field = NULL,   ### all polygons given value of 1
                              background = 0) ### all non-polygons given value of 0
    writeRaster(rast_ocean_500m, 
                ocean_500m_file,
                progress = 'text')
  } else {
    rast_ocean_500m <- raster(ocean_500m_file)
  }
  
  rast_ocean_10km <- raster::aggregate(rast_ocean_500m, 
                                     fact = 20,   ### factor of 20 aggregation
                                     fun = mean,  ### mean of 1s (ocean) and 0s (land)
                                     progress = 'text')
  
  rast_ocean_area <- rast_ocean_10km * 100 ### multiply by 100 km^2 per cell
  values(rast_ocean_area)[values(rast_ocean_area) < 1e-5] <- NA
  
  writeRaster(rast_ocean_area, ocean_area_file, overwrite = TRUE)
}

if(!file.exists(cell_id_file)) {
  rast_cell_id <- raster(ocean_area_file) %>%
    setValues(1:ncell(.))
  
  writeRaster(rast_cell_id, cell_id_file)
}

```

## Create WDPA MPA percent protection data frame

Marine regions are any protected area with MARINE flag of 1 or 2, or non-zero GIS_M_AREA.  Classify by IUCN category (I-VI -> 1-6; non-classified get 8).  Include only designated, adopted, and established parks.  Omit non-MPA management plans from U.S.  Rasterize to CHI resolution, calculate protected cells vs total cells to get percent of protection for each IUCN protection category.

Because we are rasterizing the protected areas down to 500 m resolution, we risk dropping MPAs smaller than about 1 km^2.  We assume these are not likely to have a significant impact on biodiversity protection, but see the sensitivity analysis.

### Create WDPA map at GP 500 m (.25 km^2) resolution

Actually, create two maps: one by protection category, another by year for no-take only (categories Ia, Ib, II, and no-take).

``` {r rasterize_wdpa_to_GP_500m_x_500m}

rast_cell_id    <- raster(cell_id_file)
rast_ocean_500m  <- raster(ocean_500m_file)

wdpa_marine_file <- file.path(dir_o_anx, 'wdpa/wdpa_mar_by_cat_jun2018_500m.tif')
wdpa_poly_file   <- file.path(dir_o_anx, 'wdpa/wdpa_jun2018', 
                              'WDPA_June2018-shapefile-polygons.shp')

if(!file.exists(wdpa_marine_file)) {
  
  wdpa_poly <- sf::read_sf(wdpa_poly_file)

  # wdpa_poly$IUCN_CAT %>% unique()
  iucn_cats <- c('Ia'  = 1,
                 'Ib'  = 1,
                 'II'  = 2,
                 'III' = 3,
                 'IV'  = 4,
                 'V'   = 5,
                 'VI'  = 6)
  # wdpa_poly$STATUS %>% table()
       # Adopted   Designated  Established    Inscribed Not Reported     Proposed 
       #      34       215853            2          241          128         1537 
  # wdpa_poly$NO_TAKE %>% unique()
  # x <- wdpa_poly %>% filter(NO_TAKE %in% c('All', 'Part'))
  
  wdpa_marine <- wdpa_poly %>%
    filter(MARINE > 0 | GIS_M_AREA > 0) %>%
    filter(STATUS %in% c('Designated', 'Adopted', 'Established')) %>%
      ### no paper parks!
    filter(!str_detect(tolower(MANG_PLAN), 'non-mpa')) %>%
      ### omit non-MPA fisheries or species management plans!
    mutate(NO_TAKE = ifelse(WDPAID == 309888, TRUE, NO_TAKE),
             ### patch PIPA to be no take - currently "not reported"
           no_take = (NO_TAKE == 'All') | (NO_TAKE == 'Part' & NO_TK_AREA > 0.75 * GIS_M_AREA),
             ### if NO_TK_AREA is 75% or more of GIS area, count it...
           cat = iucn_cats[IUCN_CAT],
           cat = ifelse(no_take & !cat %in% 1:2, -1, cat), ### use -1 as a "no take" flag
           cat = ifelse(is.na(cat), 8, cat)) %>%           ### use 8 as an "other protected" flag
    arrange(cat) %>%
    st_transform(crs = gp_proj4)
  
  ### rasterize all protected areas to 500m global raster;
  ### use min value: will prioritize no-take and higher levels of protection
  wdpa_all_rast_500m <- fasterize::fasterize(sf = wdpa_marine, 
                                        raster = rast_ocean_500m,
                                        field  = 'cat', 
                                        fun    = 'min')
  
  values(rast_ocean_500m)[values(rast_ocean_500m) < .005] <- NA
  wdpa_marine_rast_500m <- mask(wdpa_all_rast_500m, rast_ocean_500m)
  
  writeRaster(wdpa_marine_rast_500m, wdpa_marine_file, 
              progress = 'text',
              overwrite = TRUE)
  
}
  
# git_prov(wdpa_poly_file, 'input')
# git_prov(wdpa_marine_file, 'output') ### even in "if", mask() won't prov-register it.

```

``` {r rasterize_protection_yr_to_GP_500m}

rast_cell_id    <- raster(cell_id_file)
rast_ocean_500m  <- raster(ocean_500m_file)

wdpa_prot_yr_file <- file.path(dir_o_anx, 'wdpa', 
                               'wdpa_mar_by_prot_yr_jun2018_500m.tif')

if(!file.exists(wdpa_prot_yr_file)) {
  
  wdpa_poly <- sf::read_sf(wdpa_poly_file)

  # wdpa_poly$IUCN_CAT %>% unique()
  iucn_cats <- c('Ia'  = 1,
                 'Ib'  = 1,
                 'II'  = 2,
                 'III' = 3,
                 'IV'  = 4,
                 'V'   = 5,
                 'VI'  = 6)
  # wdpa_poly$STATUS %>% table()
       # Adopted   Designated  Established    Inscribed Not Reported     Proposed 
       #      34       215853            2          241          128         1537 
  # wdpa_poly$NO_TAKE %>% unique()
  # x <- wdpa_poly %>% filter(NO_TAKE %in% c('All', 'Part'))
  
  wdpa_no_take <- wdpa_poly %>%
    filter(MARINE > 0 | GIS_M_AREA > 0) %>%
    filter(STATUS %in% c('Designated', 'Adopted', 'Established')) %>%
      ### no paper parks!
    filter(!str_detect(tolower(MANG_PLAN), 'non-mpa')) %>%
      ### omit non-MPA fisheries or species management plans!
    mutate(NO_TAKE = ifelse(WDPAID == 309888, TRUE, NO_TAKE),
             ### patch PIPA to be no take - currently "not reported"
           no_take = (NO_TAKE == 'All') | (NO_TAKE == 'Part' & NO_TK_AREA > 0.75 * GIS_M_AREA),
             ### if NO_TK_AREA is 75% or more of GIS area, count it...
           cat = iucn_cats[IUCN_CAT],
           cat = ifelse(no_take & !cat %in% 1:2, -1, cat), ### use -1 as a "no take" flag
           cat = ifelse(is.na(cat), 8, cat)) %>%           ### use 8 as an "other protected" flag
    arrange(cat) %>%
    filter(cat <= 2) %>% ### this limits to categories Ia, Ib, II, and no-take
    st_transform(crs = gp_proj4)
  
  ### rasterize all protected areas to 500 m global raster;
  ### use min value: will prioritize no-take and higher levels of protection
  wdpa_all_rast_500m <- fasterize::fasterize(sf = wdpa_no_take, 
                                        raster = rast_ocean_500m,
                                        field  = 'STATUS_YR', 
                                        fun    = 'min')
  
  values(rast_ocean_500m)[values(rast_ocean_500m) < .005] <- NA
    ### in case of floating point not-quite-zeros...
  wdpa_yr_rast_500m <- mask(wdpa_all_rast_500m, rast_ocean_500m)
  
  writeRaster(wdpa_yr_rast_500m, wdpa_prot_yr_file, 
              progress = 'text',
              overwrite = TRUE)
  
}
  
# git_prov(wdpa_poly_file, 'input')
# git_prov(wdpa_prot_yr_file, 'output') 

```

### Crosstab WDPA map to cell IDs

Be cautious when using `raster::crosstab()` as it returns factors that need to be coerced into integers... This code results in a file of cell IDs, IUCN protected area categories (1 = Ia and Ib, 2-6 = II - VI, 7 = no take, -1 = other), and proportion of cell protected by that category.

We can't simply aggregate upwards here, since we need to keep track of different protection levels (for the first) and year (for the second).

``` {r crosstab mpa areas}

wdpa_marine_rast_500m <- raster(wdpa_marine_file)
rast_cell_id    <- raster(cell_id_file)    ### cell IDs at 10 km^2
rast_ocean_500m <- raster(ocean_500m_file)  ### ocean presence at 1 km^2
rast_ocean_area <- raster(ocean_area_file) ### ocean proportional area at 10 km^2

cell_id_500m_file <- file.path(dir_o_anx, 'spatial/cell_id_500m.tif')

### Need a 500 m raster of cell IDs for crosstabbing...
if(!file.exists(cell_id_500m_file)) {
  rast_cell_id_500m <- resample(rast_cell_id, rast_ocean_500m,
                             progress = 'text',
                             filename = cell_id_500m_file,
                             method = 'ngb',
                             overwrite = TRUE)
} else {
  rast_cell_id_500m <- raster(cell_id_500m_file)
}

wdpa_cell_area_file <- file.path(dir_spatial, 'wdpa_mpa_area.csv')

### now break into chunks and mclapply across them to crosstab WDPA categories to cell IDs
if(!file.exists(wdpa_cell_area_file)) {
  ### Break into smaller chunks for faster processing and eventual parallelizing
  n_chunks <- 60
  
  crosstab_chunk <- function(rast1, rast2, chunk, n_chunks) {
    ### chunk <- 30
    chunk_size <- ceiling(ncol(rast1) / n_chunks)
    left_bound <- (chunk - 1) * chunk_size + 1
    right_bound <- min(left_bound + chunk_size - 1, ncol(rast1))
    
    chunk_ext <- extent(rast1, 1, nrow(rast1), left_bound, right_bound)
    message('Processing ', chunk, ': ', paste0(as.character(round(chunk_ext)), collapse = ', '))
    wdpa_chunk    <- crop(rast1, chunk_ext)
    cell_id_chunk <- crop(rast2, chunk_ext)
    
    wdpa_cells <- crosstab(wdpa_chunk, cell_id_chunk, 
                           progress = 'text',
                           long = TRUE) %>%
      setNames(c('wdpa_category', 'cell_id', 'n_prot')) %>%
      mutate(wdpa_category = as.integer(as.character(wdpa_category)),
             cell_id       = as.integer(as.character(cell_id)))
        ### wdpa_category and cell_id are crosstabbed as factors - first
        ### convert to character (to unfactorize it) then to integer.  Otherwise
        ### you end up with factor index, not actual cell ID or category.
    
    return(wdpa_cells)
  }

  ### Use the function in an mclapply call
  system.time({
    wdpa_cells_list <- parallel::mclapply(1:n_chunks, mc.cores = 12,
      FUN = function(x) crosstab_chunk(wdpa_marine_rast_500m, 
                                       rast_cell_id_500m, 
                                       chunk = x, n_chunks))
  #     user   system  elapsed  USING 16 CORES at 1 km resolution...
  # 1184.324  814.096  208.082 
  #     user   system  elapsed 12 cores 500 m resolution 60 chunks
  # 4844.748  509.712  495.893   
  })
  
  wdpa_cells_df <- bind_rows(wdpa_cells_list)
  
  area_df <- data.frame(cell_id  = values(rast_cell_id),
                        area_km2 = values(rast_ocean_area))
  
  wdpa_area_df <- wdpa_cells_df %>%
    full_join(area_df, by = 'cell_id') %>%
    filter(!is.na(wdpa_category)) %>%
    mutate(prot_area_km2 = n_prot / 4, ### count of cells in 500 x 500 m raster, div by 4
           mpa_pct = prot_area_km2 / area_km2) %>%
    select(wdpa_category, cell_id, mpa_pct, prot_area_km2) %>%
      ### mpa pct is relative to *ocean* area - not *total cell* area
    group_by(wdpa_category, cell_id) %>%
    summarize(mpa_pct = sum(mpa_pct), prot_area_km2 = sum(prot_area_km2)) %>%
    ungroup()
  
  write_csv(wdpa_area_df, wdpa_cell_area_file)
  
} else {
  # git_prov(wdpa_cell_area_file, 'output')
}

```

``` {r crosstab mpa years}

wdpa_yr_rast_500m <- raster(wdpa_prot_yr_file)
rast_cell_id    <- raster(cell_id_file)    ### cell IDs at 10 km^2
rast_ocean_500m  <- raster(ocean_500m_file)  ### ocean presence at 1 km^2
rast_ocean_area <- raster(ocean_area_file) ### ocean proportional area at 10 km^2

cell_id_500m_file <- file.path(dir_o_anx, 'spatial/cell_id_500m.tif')
rast_cell_id_500m <- raster(cell_id_500m_file)

wdpa_cell_year_file <- file.path(dir_spatial, 'wdpa_mpa_year.csv')

### now break into chunks and mclapply across them to crosstab WDPA categories to cell IDs
if(!file.exists(wdpa_cell_year_file)) {
  ### Break into smaller chunks for faster processing and eventual parallelizing
  n_chunks <- 60
  
  crosstab_chunk2 <- function(rast1, rast2, chunk, n_chunks) {
    ### chunk <- 30
    chunk_size <- ceiling(ncol(rast1) / n_chunks)
    left_bound <- (chunk - 1) * chunk_size + 1
    right_bound <- min(left_bound + chunk_size - 1, ncol(rast1))
    
    chunk_ext <- extent(rast1, 1, nrow(rast1), left_bound, right_bound)
    message('Processing ', chunk, ': ', paste0(as.character(round(chunk_ext)), collapse = ', '))
    wdpa_chunk    <- crop(rast1, chunk_ext)
    cell_id_chunk <- crop(rast2, chunk_ext)
    
    wdpa_cells <- crosstab(wdpa_chunk, cell_id_chunk, 
                           progress = 'text',
                           long = TRUE) %>%
      setNames(c('mpa_year', 'cell_id', 'n_prot')) %>%
      mutate(mpa_year = as.integer(as.character(mpa_year)),
             cell_id  = as.integer(as.character(cell_id)))
        ### mpa_year and cell_id are crosstabbed as factors - first
        ### convert to character (to unfactorize it) then to integer.  Otherwise
        ### you end up with factor index, not actual cell ID or category.
    
    return(wdpa_cells)
  }

  ### Use the function in an mclapply call
  system.time({
    wdpa_cells_list <- parallel::mclapply(1:n_chunks, mc.cores = 12,
      FUN = function(x) crosstab_chunk2(wdpa_yr_rast_500m, 
                                        rast_cell_id_500m, 
                                        chunk = x, n_chunks))
  #     user   system  elapsed 
  # 1184.324  814.096  208.082 
  })
  
  wdpa_cells_df <- bind_rows(wdpa_cells_list)
  
  area_df <- data.frame(cell_id  = values(rast_cell_id),
                        area_km2 = values(rast_ocean_area))
  
  wdpa_year_df <- wdpa_cells_df %>%
    full_join(area_df, by = 'cell_id') %>%
    filter(!is.na(mpa_year)) %>%
    mutate(prot_area_km2 = n_prot / 4, 
              ### count of cells in 500 x 500 m^2 raster, times .25 km^2 area per cell
           mpa_pct = prot_area_km2 / area_km2) %>%
    select(mpa_year, cell_id, mpa_pct, prot_area_km2) %>%
      ### mpa pct is relative to *ocean* area - not *total cell* area
    group_by(mpa_year, cell_id) %>%
    summarize(mpa_pct = sum(mpa_pct), prot_area_km2 = sum(prot_area_km2)) %>%
    ungroup()
  
  write_csv(wdpa_year_df, wdpa_cell_year_file)
  
} else {
  # git_prov(wdpa_cell_year_file, 'output')
}

```

### View WDPA protected area proportions as raster

Proportional protection can be multiplied by ocean area raster to get area of protection.  Collect by category (to avoid duplicate "by" values):

* No Take (categories 1 & 2 and specifically designated "no take")
    * classified as 1, 2, and -1 respectively
* Conservation (categories 1-4 plus no take)
    * classified as 1, 2, 3, 4, and -1 (no take)
* All protection (non-NA)
    * classified as 1-6, -1 (no take), and 8 (other protection)

Note: these are not saved as separate rasters at this point... they are easily created from the dataframe of cell ID to protected proportion.

``` {r}

wdpa_area_df <- read_csv(wdpa_cell_area_file)

notake_df <- wdpa_area_df %>%
  filter(wdpa_category <= 2) %>%
  group_by(cell_id) %>%
  summarize(mpa_pct = sum(mpa_pct))

conservation_df <- wdpa_area_df %>%
  filter(wdpa_category <= 4) %>%
  group_by(cell_id) %>%
  summarize(mpa_pct = sum(mpa_pct))

all_prot_df <- wdpa_area_df %>%
  group_by(cell_id) %>%
  summarize(mpa_pct = sum(mpa_pct))

notake_raster <- subs(rast_cell_id, notake_df, by = 'cell_id', which = 'mpa_pct')
plot(notake_raster, main = 'No take protection (Ia, Ib, II + no take)')

conservation_raster <- subs(rast_cell_id, conservation_df, by = 'cell_id', which = 'mpa_pct')
plot(conservation_raster, main = 'Conservation protection (Ia - IV + no take)')

all_prot_raster <- subs(rast_cell_id, all_prot_df, by = 'cell_id', which = 'mpa_pct')
plot(all_prot_raster, main = 'All protection (any category)')
```

-----

``` {r prov_footer, results = 'asis'}
# prov_wrapup(commit_outputs = FALSE)
```

